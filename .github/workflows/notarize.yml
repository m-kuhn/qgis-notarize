name: Notarize and Release DMG

on:
  repository_dispatch:
    types: [new-release]
  push:

jobs:
  notarize:
    runs-on: macos-latest
    env:
      KEYCHAIN_NAME: notary-keychain
      KEYCHAIN_PASSWORD: dummy

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      - name: Download artifact from qgis/QGIS
        run: |
          gh run download 15379869828 \
            --repo qgis/QGIS \
            --name qgis-PR60039-dmg \
            --dir ./downloaded-artifacts
            
      - name: Import signing certificate
        run: |
          echo "${{ secrets.APPLE_DEVELOPER_ID_P12_BASE64 }}" | base64 --decode > cert.p12
          P12_PATH=cert.p12
          P12_PASSWORD=${{ secrets.APPLE_DEVELOPER_ID_P12_PASSWORD }}
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security import "$P12_PATH" -k "$KEYCHAIN_NAME" -P "$P12_PASSWORD" -T /usr/bin/codesign
          security set-keychain-settings -t 3600 -l "$KEYCHAIN_NAME"
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | tr -d '"')
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

      - name: Mount the DMG
        id: mount
        run: |
          MOUNT_OUTPUT=$(hdiutil attach ./downloaded-artifacts/*.dmg)
          echo "$MOUNT_OUTPUT"
          MOUNT_POINT=$(echo "$MOUNT_OUTPUT" | grep -oE '/Volumes/.*' | head -n 1)
          echo "MOUNT_POINT=$MOUNT_POINT"
          ls "$MOUNT_POINT"
          cp -R "$MOUNT_POINT"/*.app .

      - name: Clean and sign app
        run: |
          APP_PATH=$(echo ./*.app)

          # Step 0: relocate python files
          MACOS_DIR="$APP_PATH/Contents/MacOS"
          PLUGIN_DIR="$APP_PATH/Contents/PlugIns"
          FRAMEWORKS_DIR="$APP_PATH/Contents/Frameworks"
          SCRIPT_DIR="$APP_PATH/Contents/Resources/scripts"
          PYTHON_DIR="$APP_PATH/Contents/Resources/python3.11"

          # Make target script directory
          mkdir -p "$SCRIPT_DIR"

          # Find non-Mach-O files in Contents/MacOS (Should be py files)
          find "$MACOS_DIR" -type f -exec file {} \; | grep -v 'Mach-O' | cut -d: -f1 | while read -r file; do
            fname=$(basename "$file")
            echo "Relocating $fname"

            # Move to scripts dir
            mv "$file" "$SCRIPT_DIR/$fname"

            # Create symlink back in MacOS dir
            ln -s "../Resources/scripts/$fname" "$MACOS_DIR/$fname"
          done

          # Find leftover files to be removed
          find "$APP_PATH" -type f \( -name "*.o" -o -name "*.a" -o -name "*.prl"  -o -name "*.la" -o -name "*.pyc" \) -print -delete

          PYTHON_MODULES_DIR=$(find "$FRAMEWORKS_DIR/lib" -maxdepth 1 -type d -name "python3.*" | head -n 1)

          mv "$PYTHON_MODULES_DIR" "$PYTHON_DIR"
          ln -s "../../Resources/python3.11" "$PYTHON_MODULES_DIR"

          # Find non-Mach-O files in Frameworks
          non_macho_files=$(find "$FRAMEWORKS_DIR" -type f -exec file {} \; | grep -v 'Mach-O' | cut -d: -f1)

          if [ -n "$non_macho_files" ]; then
            echo "❌ Found non-Mach-O files in Frameworks (not allowed):"
            echo "$non_macho_files"
            echo "💥 Aborting. You must relocate or remove these files."
            exit 1
          fi

          # Warn if Mach-O files are in strange subfolders (like python3.11)
          bad_locations=$(find "$FRAMEWORKS_DIR/lib/python3.11" -type f -exec file {} \; 2>/dev/null | grep 'Mach-O' | cut -d: -f1)

          if [ -n "$bad_locations" ]; then
            echo "❌ Found Mach-O binaries inside Python lib folders (also not allowed):"
            echo "$bad_locations"
            echo "💥 Aborting. These should be in Frameworks/, not under lib/python3.11."
            exit 1
          fi

          echo "✅ Frameworks folder is clean and ready for signing."

          # Step 1: Sign all signable files inside the .app
          find "$APP_PATH" -type f \
            -name "*.so" -or \
            -name "*.dylib" -or \
            -perm +111 \
            -print0 | while IFS= read -r -d '' file; do
            # Only sign Mach-O binaries
            if file "$file" | grep -q 'Mach-O'; then
              echo "Signing: $file"
              codesign --remove-signature "$file" 2>/dev/null || true
              codesign --force --sign "Developer ID Application" --keychain "$KEYCHAIN_NAME" "$file" || {
                echo "⚠️ Failed to sign: $file"
              }
              lipo -info "$file"
              codesign -dv "$file" 2>&1 | grep -i 'identifier\|signing time\|authority\|flags\|CDHash' || echo "❌ $file is unsigned or broken"
            fi
          done

          # Step 2: Sign embedded .frameworks and .app bundles
          find "$APP_PATH" -type d \( -name "*.framework" -or -name "*.app" \) -print0 | while IFS= read -r -d '' bundle; do
            echo "Signing bundle: $bundle"
            codesign --force --sign "Developer ID Application" --keychain "$KEYCHAIN_NAME" "$bundle"
          done

          # Step 3: Sign top-level .app with hardened runtime (for notarization)
          codesign --force --options runtime --sign "Developer ID Application" --keychain "$KEYCHAIN_NAME" "$APP_PATH"

          # Step 4: Verify
          codesign --verify --deep --strict "$APP_PATH"


      - name: Recreate DMG (clean signed app)
        run: |
          APP_PATH=$(echo ./*.app)

          # Build a new compressed, notarization-ready DMG
          hdiutil create \
            -volname "QGIS Installer" \
            -srcfolder $APP_PATH \
            -fs HFS+ \
            -format UDZO \
            notarized.dmg

          codesign --sign "Developer ID Application" --keychain "$KEYCHAIN_NAME" --timestamp notarized.dmg

      - name: Presubmission check
        run: |
          #!/bin/bash
          APP_PATH="$(echo ./*.app)"
          DMG_PATH="notarized.dmg"

          echo "🔍 Verifying .app and .dmg structure before notarization"

          ### 1. Verify .app exists
          if [ ! -d "$APP_PATH" ]; then
            echo "❌ ERROR: App bundle not found at $APP_PATH"
            exit 1
          fi

          ### 2. Check for unallowed file types
          echo "🧹 Checking for unwanted build artifacts..."
          find "$APP_PATH" -type f -name "*.o" -o -name "*.a" -o -name "*.prl" -o -name "*.la" -o -name "*.pyc" -print

          ### 3. Check for unsigned Mach-O binaries
          echo "🔐 Verifying each Mach-O binary is signed..."
          find "$APP_PATH" -type f -exec file {} \; | grep 'Mach-O' | cut -d: -f1 | while read -r f; do
            if ! codesign -dvv "$f" >/dev/null 2>&1; then
              echo "❌ Not signed or broken signature: $f"
              exit 1
            fi
          done

          ### 4. Check .app with deep signature verification
          echo "✅ Verifying full app bundle signature..."
          if ! codesign --verify --deep --strict --verbose=2 "$APP_PATH"; then
            echo "❌ App bundle verification failed"
            exit 1
          fi

          ### 5. Print top-level app entitlements
          echo "📄 App entitlements:"
          codesign -d --entitlements :- "$APP_PATH" || echo "⚠️ No entitlements found (may be OK)"

          ### 6. Check .dmg exists and is signed
          if [ ! -f "$DMG_PATH" ]; then
            echo "❌ ERROR: DMG not found at $DMG_PATH"
            exit 1
          fi

          echo "🔐 Verifying .dmg signature..."
          if ! codesign -dv "$DMG_PATH" >/dev/null 2>&1; then
            echo "❌ DMG is not signed. Use codesign before submitting:"
            echo "codesign --sign 'Developer ID Application' --timestamp --keychain \"$KEYCHAIN_NAME\" $DMG_PATH"
            exit 1
          fi

          echo "✅ Pre-submission checks passed. Safe to submit to notarytool."

      - name: Notarize the new DMG
        run: |
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > authkey.p8
          xcrun notarytool submit notarized.dmg \
            --key authkey.p8 \
            --key-id "${{ secrets.API_KEY_ID }}" \
            --issuer "${{ secrets.API_KEY_ISSUER_ID }}" \
            --wait

      - name: Show notarization log
        if: failure()
        run: |
          echo "${{ secrets.APPSTORE_PRIVATE_KEY }}" > authkey.p8

          echo "📦 Getting latest notarization submission UUID..."
          HISTORY=$(xcrun notarytool history \
            --key authkey.p8 \
            --key-id "${{ secrets.API_KEY_ID }}" \
            --issuer "${{ secrets.API_KEY_ISSUER_ID }}" 
          
          echo $HISTORY
          UUID=$(echo "$HISTORY" | grep 'ID:' | head -n 1 | awk '{print $2}'))

          echo "✅ Submission ID: $UUID"
          echo "📄 Fetching notarization log..."

          xcrun notarytool log "$UUID" \
            --key authkey.p8 \
            --key-id "${{ secrets.API_KEY_ID }}" \
            --issuer "${{ secrets.API_KEY_ISSUER_ID }}"

      - name: Staple the DMG
        run: |
          xcrun stapler staple notarized.dmg

      
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: always()
        env:
          KEYCHAIN_NAME: notary-keychain
          KEYCHAIN_PASSWORD: dummy

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: notarized-dmg
          path: notarized.dmg
